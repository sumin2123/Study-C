### 1.변수 선언하기

## int a ;  

**int** = 자료형 = 변수의 크기를 나타냄

**a** = 변수명 = 메모리에 붙이는 임시 주소



* **쓰레기  값**

변수를 선언하면 메모리 공간이 생기는데,

 이  공간은 프로그램 종료 시 사용하던 메모리 공간을 **반납**하면서 

새롭게 실행된 프로그램이 그 공간을 사용하며 공간이 **재활용**된다.

이때, 이전에 사용했던 프로그램이 남긴 값 = **쓰레기 값** 이라고 하며, 초기화 없이 그냥 실행하면 이것이 **오류를 발생**시킨다! 

이 오류를 없애 주기위해서 우리는 원하는 값으로 바꾸는 **초기화**를 진행해야한다.

**그럼 이 초기화 과정은 어떻게 진행할까?**

a = 10; 	<=  **초기화 과정**

여기서, **대입연산자 ( = )** 는 오른쪽 (10)값을 왼쪽 (변수a)에 저장(할당)한다.

```c
#include <stdio.h>

int main(void)
{
    /*데이터의 종류별로 변수를 선언*/
	int a;			//int형 변수 a 선언
	int b, c;		// 2개의 int형 변수 b,c를 동시에 선언
	double da;		// double형 변수 da선언
	char ch;		// Char형 변수 ch 선언
    
	a = 10;			// int형 변수 a에 정수 10대입
	b = a;			// int형 변수 b에 변수 a 대입
	c = a + 20;		// int형 변수 c에 a + 20 값 대입
	da = 3.5;		// double형 변수 da에 실수 3.5 대입
	ch = 'A';		// char형 변수 ch에 문자 'A' 대입

	printf("변수 a의 값 : %d\n ", a);
	printf("변수 b의 값 : %d\n",b);
	printf("변수 c의 값 : %d\n",c);
	printf("변수 da의 값 : %.1lf\n ",da);
	printf("변수 ch의 값 : %c\n",ch);

	return 0;
}
```



* 변수 선언과 대입 규칙

  1) 중괄호의 블록{} 안에 변수를 선언하며, 선언한 위치부터 블록 끝까지 사용할 수 있다.

  2) 컴파일러에 따라 변수의 선언 위치가 제한될 수  있다.

  3) 변수형의 자료형이 같으며 동시에 둘 이상의 변수를 선언 할 수 있다.

  4) 대입 연산자(=)는 연산자 왼쪽의 변수에 오른쪽의 값을 저장한다.( 반대로는 불가능  )

  5) 대입 연산자 왼쪽에서는 저장 공간이 되고, 오른쪽에서는 값이 된다.( 변경 불가능 ) 



---

### 2. 정수 자료형

앞에서 **변수 = 데이터를 저장한는 메모리 공간** 이라고 하였다.

이 변수의 형태를 **자료형** or **데이터형** 이라고도 하며,

크게는 **정수형** 과 **실수형** 으로 구분한다.

여기서 먼저 **정수형** 에 대해서 알아보자.



**정수형** 은 메모리 **저장 공간의 크기**에 따라 나눌 수 있다.



■char 		← 	1byte
	
■■short	 	← 	2byte
	
■■■■int  	← 	4byte
	
■■■■long	← 	4byte

■■■■■long long 	     ← 	8byte



여기서, char 형은 가장 작은 범위를 저장할 수 있지만, 주로 문자를 저장하는 용도로 쓰인다. 

* char 형 변수의 사용

```c
#include <stdio.h>

int main()
{
	char ch1 = 'A';		//문자로 초기화. 저장된 값은 문자의 아스키 코드 값
	char ch2 = 65;		// 문자 'A'의 아스키 코드 값에 해당하는 정수로 초기화

	printf("문자 %c의 아스키 코드 값 : %d\n", ch1, ch1);
	printf("아스키 코드 값이 %d인 문자 : %c\n", ch2, ch2);

	return 0;
}
```

**컴파일러**는 모든 문자를 0 ~ 127  사이의 정수(아스키 코드 값)으로 변경하여 처리하기때문에

##### char형 변수를 사용하면 문자를 가장 효과적으로 저장할 수 있다.



물론, char 형 변수만 사용하는 것은 아니다.

이외에도 많은 자료형이 있으며, 처리할 데이터의 크기에 따라 적절한 자료형을 선택하면 된다.

- 여러 가지 정수형 변수

```c
#include <stdio.h>

int main()
{
	short sh = 32767;			// short 형의 최댓값 초기화
	int in = 2147483647;			//  int 형의 최댓값 초기화
	long ln = 2147483647;			//  long 형의 최댓값 초기화
	long long lln = 123451234512345;	//  아주 큰 값 초기화

	printf("short형 변수 출력 : %d\n", sh);
	printf("int형 변수 출력 : %d\n", in);
	printf("long형 변수 출력 : %ld\n", ln);
	printf("long long형 변수 출력 : %lld\n", lln);
	// long long 형은 lld로 출력


	return 0;
}
```



각 자료형은 저장 값의 범위가 다르지만, 출력할 때는 모두 **%d**를 사용한다.

단, long형은 **%ld** , longlong  형은 **%lld** 로 출력한다.

그럼, 언제 어떤 자료형을 사용하면 될까?

1. 특별한 경우가 아니면 정수형 int를 사용한다. (연산이 가장 빠르다)
2. long형은 큰 값을 저장할 때만 사용한다. 
3. 자료형의 크기를 모른다면 sizeof 연산자를 사용해서 크기를 알아본다.

``` c
printf("longlong형의 크기 : %d바이트\n", sizeof(longlong));
```



---

### 3.unsigned 정수 자료형

방금 앞에서 배운 자료형은 양수와 음수 모드 저장가능하였다. 

하지만, 양수만 저장한다면 두 배 더 넓은 범위의 값을 저장할 수 있다.

이때, unsigned를 사용한다.

unsugned는 정수형을 양수 전용으로 쓰고 싶을 때 사용하며,

일반적인 int a; 에는 자동으로 signed로 선언되기 때문에 우리 눈에는 보이지 않는 것이다.

```c
#include <stdio.h>

int main(void)
{
    unsigned int a;
    
    a = 4294967295;		//	큰 양수 저장
    prtinf("%d\n", a);	// %d로 출력
    a = -1;				// 음수 저장
    printf("%u\n", a);	// %u로 출력
    
    return 0;
}

// 결과
-1
4294967295
```

출력한 값을 보면 저장한 값과 반대로 출력이 되었다.

이유는, 저장되는 형태는 같으나, 해석해서 보여주는 방법이 다르기 때문이다.

##### %d = 부호까지 생각해서 10진수로 출력하는 변환문자

##### %u = 부호 없는 10진수로 출력하는 변환문자



------

### 4.실수 자료형

데이터를 구현하는 방법이 정수와 다르기 때문에, **별도의 자료형을 사용**한다.

		■  ← 1byte			(유효숫자) 
	
				 	 ■■■■  float(7)  	
	
			■■■■■■■■ double (15)-

 ■■■■■■■■  long double (15 이상)



정수랑 다르게 실수에서는 값의 범위보다 **유효숫자의 개수**에 주목할 필요가 있다.

**유효숫자** 는 많을수록 더 정확한 값을 표현 할 수있다.

```c
#include <stdio.h>

int main(void)
{
	
	float ft = 1.234567890123456789;		// 유효 숫자가 많은 값으로 초기화
	double db = 1.234567890123456789;

	printf("float형 변수의 값 : %.20f\n", ft);	// 소수점 이하 20자리까지 출력
	printf("double형 변수의 값: %.20lf\n", db);

	return 0;
}

```

컴퓨터에서 실수 표현은 오차가 있기 때문에

자료형에 따라 유효 숫자 범위 내에서 사용해야 한다.

##### 	[ 특징 ]

1. 정수형이 기본이며, 실수형은 꼭 필요한 경우 사용한다.	
2. 실수형은 유효숫자가 많은 double형을 기본으로 사용한다.
3. 컴파일러 마다 구현방식이 다르다면, **코드 호환성**을 보장하지 못하기 때문에, 주의해서 사용해야한다.

------

### 5.문자열 저장

```c
#include <stdio.h>

int main(void)
{
    char fruit[20] = "strawberry";	//char 배열 선언과 문자열 초기화
    
    printf("딸기 : %s\n", fruit);				//배열명으로 저장된 문자열 출력
    printf("딸기쨈 : %s %s\n", fruit, "jam"); // 문자열 상수를 직접 %s로 출력 
    
    return 0;    
}
```



#### `char fruit[6] = "apple";`

			fruit  = 배열명
	
			[ 6 ]  =  문자열의 길이 +1 이상  (null 문자때문에 +1 을 해준다.)



* 배열에는 대입 연산자를 사용할 수 없다. ( 단, 선언할 때에는 제외) 

  배열이름은 = 주소 = 상수

  대입연산자 왼쪽에는 상수가 올 수 없기 때문에, 사용할 수 없다. 



* char 배열에 문자열 복사

  앞에서 배열에는 대입 연산자를 사용할 수 없다고 하였다, 그럼 **새로운 문자열**을 저장하려면 어떻게 해야할까?

  이때에는 **strcpy 함수**를 사용한다.

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>		// 문자열을 다룰 수 있는 string.h 헤더 파일 포함

int main(void)
{

	char fruit[20] = "strawberry";	// strawberry로 초기화

	printf("%s\n", fruit);			// strawberry 출력
	strcpy(fruit, "banana");		// fruit에 banana 복사
	printf("%s\n", fruit);			// banana 출력

	return 0;
}

```

⁜ 컴파일 오류가 발생했을 때 , 소스 코드 첫 줄에 `#define _CRT_SECURE_NO_WARNINGS` 을 사용한다.



---

### 6.const를 사용한 변수

```c
#include <stdio.h>

int main()
{
	int income = 0;							// 소득액 초기화
	double tax;								// 세금
	const double tax_rate = 0.12;			// 세율 초기화

	income = 546;							// 소득액 저장
	tax = income * tax_rate;				// 세금 계산
	printf("세금은 : %.1lf입니다.\n", tax);

	return 0;
}
```

* const를 사용한 변수는 초깃값이 수정이 불가능하다.

  => 상수처럼 사용가능



---

### 7. 예약어와 식별자

* **예약어**는 컴파일러와 사용 방법이 약속된 단어 ex) 자료형 이름
* **식별자**는 필요에 따라 사용자가 만들어 사용하는 단어 ex) 변수

#### [ 식별자 만드는 규칙 ]

1. 알파벳 대소문자, 숫자, 밑줄(_) 로 만든다.  

   ex) `make_money` / `Be-apple ~ (x)`

2. 숫자로 시작할 수 없다. 

    ex) `1num (x) / num1 (O)`

3. 대문자와 소문자는 서로 다른 식별자로 인식한다.( 대소문자 구별 )\

   ex)  `apple != APPLE`

4. 예약어는 식별자로 사용할 수 없다.

   ex) `short (x)`



---

### 8. scanf 함수의 사용법

#### ` scanf("%d", &a); `

			%d 	=	int형 변환 문자
	
			   &	 = 	변수명 앞에 붙인다.
	
				a	 =	변수명

* scanf 함수를 사용한 입력

  ``` c
  #include <stdio.h>
  
  int main(void)
  {
      int a;
      
      scanf("%d", &a);				// 여기서 변수 a에 값 입력
      printf("입력된 값 : %d\n", a);	 // 입력한 값 출력
      
      return 0;
  }
  ```

  scanf 함수는 **입력 값을 받는 함수**로, 실행 시 원하는 값을 **입력** 할  수 있다.

  이렇게 입력을 받으려면 자료형에 따른 **입력 변환 문자**와 변수 앞에 **&**를 사용한다.

  하지만 **문자열 입력** 은 char배열(%s) 을 이용하며, **&**기호를 사용하지 않는다.



		만약, 여러가지 값을 한번에 받아서 입력하고 싶을 때는 어떻게 하면 될까?
	
		다음과 같이 연속 입력이 가능하다.

* scanf 함수를 사용한 연속 입력

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      int age;						// 나이는 정수형
      double height;					// 키는 실수형
      
      printf("나이와 키를 입력하세요 : ");	// 입력 안내 메시지 출력
      scanf("%d%lf", &age, &height);	   // 나이와 키를 함께 입력
      printf("나이는 %d살, 키는 %.1lfcm입니다\n", age, height);	// 입력값 출력
      
      return 0;
  }
  ```

  이렇게 연속 값을 입력 받을 수 있으며,

  **둘 이상의 값을 입력** 시 에는 [ Space Bar ], [ Tab ], [ Enter ] 로 구분하여 준다.

  [ Space Bar ] : `나이와 키를 입력하세요 : 23 168.7` 

  	 [ Tab ]	   : `나이와 키를 입력하세요 : 23	168.7` 

    [ Enter ]	

  ```c
  나이와 키를 입력하세요 : 23	
  					  168.7 
  ```

  

---

### 9. 문자 & 문자열의 입력

```c
#include <stdio.h>

int main(void)
{
    char grade;			// 학점을 입력할 변수
    char name[20];		// 이름을 입력할 배열
    
    printf("학점 입력 : ");
    scanf("%c", &grade);	// grade 변수에 학점 문자 입력
    
    printf("이름 입력 : ");
    scanf("%s", name);	// name 배열에 이름 문자열 입력, &를 사용하지 않는다.
    
    printf("%s의 학점은 %c입니다.\n", name, grade);
    
    return 0;
}
```







---

## [ 마지막 정리 ]

1. **변수 선언**으로 메모리에 저장 공간을 확보하여, 

   대입 연산자( = )로 변숫값을 초기화하거나 값을 저장한다.

   초기화하지 않은 변수에는 **쓰레기 값** 이 들어 있다.

   

2. 변수의 형태를 **자료형**이라 하며, 정수형과 실수형으로 나눈다.

 

3. 변수에 **const**를 사용하면 상수처럼 사용할 수 있다.



4. **예약어**는 컴파일러와 약속된 단어이고,

   **식별자**는 사용자가 만들어낸 단어이다.



5. **scanf 함수** 로 입력할 때 변수 앞에 &를 사용한다.



6. **둘 이상의 값을 입력** 할 때는  [ Space Bar ], [ Tab ], [ Enter ] 로 구분한다.



7. **문자열 입력** 은 char 배열을 이용하며, &기호를 사용하지 않는다.



#### [ 표로 정리하기 ]

* 정수형 종류

|  자료형  | 크기(Byte) |                        값의 저장 범위                        | 출력 변환 문자 |
| :------: | :--------: | :----------------------------------------------------------: | :------------: |
|   char   |     1      |                          -128 ~ 127                          |  %c  또는 %d   |
|  short   |     2      |                       - 32768 ~ 32767                        |       %d       |
|   int    |     4      |                  - 2147483648 ~ 2147483647                   |       %d       |
|   long   |     4      |                  - 2147483648 ~ 2147483647                   |      %ld       |
| longlong |     8      | ![img](file:///C:\Users\mini2\AppData\Local\Temp\DRW000020886ce0.gif) ~ ![img](file:///C:\Users\mini2\AppData\Local\Temp\DRW000020886ce6.gif) |      %lld      |



* unsigned 정수 자료형

|     자료형     | 크기(Byte) | 값의 저장 범위 | 출력 변환 문자 |
| :------------: | :--------: | :------------: | :------------: |
| unsigned char  |     1      |     0~ 255     |       %u       |
| unsigned short |     2      |   0 ~ 65535    |       %u       |
|  unsigned int  |     4      | 0 ~ 4294967295 |       %u       |
| unsigned long  |     4      | 0 ~ 4294967295 |      %lu       |



* 실수형 종류

|   자료형    | 크기(Byte) | *유효 숫자 | 출력 변환 문자 |
| :---------: | :--------: | :--------: | :------------: |
|    float    |     4      |     7      |       %f       |
|   double    |     8      |     15     |      %lf       |
| long double |   8 이상   |  15 이상   |      %Lf       |



* 자료형에 따른 입력 변환 문자

| 데이터 종류 | 자료형               | 크기(Byte)    | 입력 변환 문자 |
| ----------- | -------------------- | ------------- | -------------- |
| 정수        | (unsigned) short     | 2             | %hd (%hu)      |
|             | (unsigned) int       | 4             | %d (%u)        |
|             | (unsigned) long      | 4             | %ld (%lu)      |
|             | (unsigned) long long | 8             | %lld (%llu)    |
| 실수        | float                | 4             | %f             |
|             | double               | 8             | %lf            |
|             | long double          | 8, 10, 12, 16 | %Lf            |
| 문자        | char                 | 1             | %c             |
| 문자열      | char 배열            | 가변적        | %s             |



---

3 강 변수와 데이터

	끝 	> - <
