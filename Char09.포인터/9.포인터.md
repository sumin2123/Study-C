## 1. 포인터의 기본 개념

변수 = 메모리 공간  /  변수명 = 공간 식별 이름

단, 서로 다른 함수(블럭)에 존재하면 전혀 다른 변수로 사용이 된다.

이러한 경우에도 데이터를 공유할 수 있게 하기 위해 **포인터** 를 사용한다.



* 메모리의 주소

메모리 = 데이터를 넣고 꺼내는 공간으로 찬장과 같다고 하자.

우리는 이 찬장의 위치를 알아야지 찬장에 있는 물건(데이터)를 꺼낼 수 있다.

프로그램에서는 사용하는 메모리의 위치를 **주소 값**으로 식별할 수 있다.

이러한 주소값은 **byte(바이트)** 단위로 구분 된다.

![image-20210505150051346](C:\Users\PKNU\AppData\Roaming\Typora\typora-user-images\image-20210505150051346.png) < = 메모리 ( 주소 1개당 1byte 할당 )



---

## 2. 주소 연산자 &

##### 주소 = 변수가 할당된 메모리 공간의 시작 주소

주소 연산자 & 를 사용해서 구현하며, 원하는 위치부터 변수의 크기만큼 메모리 사용이 가능하다.

```c
#include <stdio.h>

int main(void)
{
    //변수  선언문 실행 
	int a;		// int형 변수선언
	double b;	// double형 변수 선언
	char c;		// Char형 변수 선언

	printf("int형 변수의 주소 : %u\n", &a);	// 주소 연산자로 주소 계산
	printf("double형 변수의 주소 : %u\n", &b);
	printf("char형 변수의 주소 : %u\n", &c);

	return 0;

}
```

```c
>>	int형 변수의 주소 : 15727976
	double형 변수의 주소 : 15727960
	char형 변수의 주소 : 15727951
```

변수 선언문이 실행되면, 각 자료형의 크기만큼 메모리에 저장 공간이 할당된다.

이때, 주소연산자& 를 사용하면 변수가 할당된 메모리 공간의 시작 주소 값을 알 수 있다.


#### &변수명 

 변수에 할당된 메모리의 시작 주소를 확인하고,

시작 주소에 변수의 크기를 더하면 변수의 메모리의 할당 범위를 알 수 있다.



---

## 3. 간접참조연산자 ( * )

앞에서는 단지 메모리의 주소를 출력하는 법을 알아보았다.

하지만, 필요할 때마다 계속 주소 연산을 수행하는 것은 불편하기에 한 번 구한 주소를 저장해서 사용하는법을 알아보자.

#### 포인터

**변수의 메모리 주소를 저장하는 변수**로 일반 변수와 마찬가지로 선언 후 사용한다.

다만, 선언할 때 변수 앞에 * 만 붙여주면된다.

```c
#include <stdio.h>

int main(void)
{
	int a;		//일반 변수 선언
	int* pa;	// 포인터 변수

	pa = &a;	// 포인터에 a의 주소 대입
	*pa = 10;	// 포인터로 변수 a에 10대입

	printf("포인터로 a값 출력 : %d\n", *pa);
	printf("변수명으로 a값 출력 : %d\n", a);
    // 변수 a 값 출력

	return 0;
}
```

```c
>>	포인터로 a값 출력 : 10
	변수명으로 a값 출력 : 10
```

#### 		

###			자료형 *변수명; 	

포인터 이름을 짓고, 변수명 앞에 *를 붙인다.

여기서 *는 포인터임을 표시하는 기호이다.

 포인터의 자료형은 변수의 자료형을 적어준다.

여기서, 포인터 자료형은 저장할 주소가 어떤 변수의 주소인지 그 변수의 자료형을 적는다.

### `` int *pa;`` 

포인터 변수가 할당되면, 일반 변수와 마찬가지로 메모리 저장공간이 할당되고, 이후에는 변수명으로 사용할 수 있다.

```c
pa = &a;	//포인터에 a의 주소 대입
```

###  pa ← a	 포인터 pa는 변수 a를 가리킨다.

즉, *pa로 변수 a를 사용할 수 있다. ( *pa == a)

```c
*pa = 10
printf("a의 값은 : %d", a);
>> a의 값은 : 10
```



이렇게 배운 포인터를 이용한 사용법을 알아보자.

* 포인터를 사용한 두 정수의 합과 평균

```c
#include <stdio.h> 

int main(void)
{
	int a = 10, b = 15, total;	//변수 선언과 초기화
	double avg;		// 평균을 저장할 변수
	int *pa, *pb;	// 포인터 동시 선언
    
	int *pt = &total; 	// 포인터 선언과 초기화
	double *pg = &avg;	// double형 포인터 선언과 초기화

	pa = &a;	//포인터 pa에 변수 a의 주소 대입
	pb = &b;	//포인터 pb에 변수 b의 주소 대입

	*pt = *pa + *pb;	// total = a + b 와 같음 
	*pg = *pt / 2.0;	// avg = total / 2.0 

	printf("두 정수의 값 : %d, %d\n", *pa, *pb);
	printf("두 정수의 합 : %d\n", *pt);
	printf("두 정수의 평균 :%.1lf\n", *pg);

	return 0;

}
```

```c
>>	두 정수의 값 : 10, 15
	두 정수의 합 : 25
	두 정수의 평균 :12.5
```



---

## 4. const를 사용한 포인터

##### const  = 가리키는 변수의 값을 바꿀 수  없다.

라는 의미로, 이렇게되면 변수이 사용하는 것과는 다른 의미를 가진다.

```c
#include <stdio.h> 

int main(void)
{
	int a = 10, b = 20;
	const int *pa = &a;		//*pa는 변수 a를 가리킨다
 
	printf("변수 a값 : %d\n", *pa);	// 포인터를 간접 참조하여 a 출력
	pa = &b;		// 포인터가 변수 b를 가리키게 된다.

	printf("변수 b값 : %d\n", *pa);	//포인터를 간접 참조하여 b 출력
	pa = &a;		// 포인터가 다시 변수 a를 가리킨다
	a = 20;			// a를 직접 참조하여 값을 바꾼다.

		printf("변수 a값 : %d\n", *pa);
    // 포인터로 간접 참조하여 바뀐 값 출력

	return 0;
}
```

```c
>>	변수 a값 : 10
	변수 b값 : 20
	변수 a값 : 20
```

``const int *pa = &a;`` 에서 *pa를 선언할 때 const로 상수화 하였다.

만약, const가 일반 변수처럼 포인터 값을 고정시킨다면,  ``pa = &b;`` 에서 pa는 다른 변수의 주소를 저장 할 수 없다.

하지만 출력 결과에서 pa는 const의 사용과 무관하게 변수 b의 주소를 저장하고, 간접 참조해 출력하고 있다.

#### 왜 이런걸까?

 ``const int *pa = &a;`` 여기서 사용된 const의 의미는

#### *pa가 가리키는 변수 a는 pa를 간접 참조해서 바꿀수 없다.

그렇기에, ``*pa = 20;`` 처럼 pa의 값을 통해 a를 바꾸려고 하면 에러가 발생한다.

 
 
* 응용 문제 ( 한번 생각해보고 실행해보자)

```c
#include <stdio.h> 

int main(void)
{
	int a = 10, b = 20;
	const int *pa = &a; // 포인터가 가리키는 곳의 데이터를 상수화 ( 주소변경 O)
	int* const pb = &b; // 포인터 자체가 상수화 ( 주소변경 X )

	printf("변수 a값 : %d\n", *pa);
	pa = &b;
	b = 50;

	printf("변수 b값 : %d\n", *pa);
	pa = &a;
	a = 20;

	printf("변수 a값 : %d\n", *pa);
	printf("변수 b값 : %d\n", *pb);

	return 0;
}
```

```c
>>	변수 a값 : 10
	변수 b값 : 50
	변수 a값 : 20
	변수 b값 : 50
```

 

---

### [ 중간 정리 ]

1. **포인터**는 메모리를 사용하는 또 다른 방법이다.
2. **주소 연산자 &** 로 변수가 할당된 메모리의 위치를 확인한다.
3. 포인터로 가리키는 변수를 사용할 때 **간접 참조 연산자 * ** 를 사용한다.



* 주소 연산자 ( 변수가 할당된 메모리의 시작 주소 값 구함)

### ``int a;`` ``& a``



* 포인터 ( 시작 주소 값을 저장하는 변수, 가리키는 자료형을 표시하여 선언한다. )

### ``char *pc;`` ``int *pa`` ``double *pd``



* 간접 참조 연산자 ( 포인터에 사용, 포인터가 가리키는 변수를 사용 )

### ``*pi = 10;``
---

# 9-2. 포인터 이해

포인터 = 주소를 저장하는 일정한 크기의 메모리 공간

따라서, 언제든지 다른 **주소를 저장**하거나 **포인터끼리 대입**할 수  있다.

#### 포인터 = 변수

단, 일반 변수와 달리 **엄격한 기준이 적용** 된다.



### 1. 주소와 포인터 차이

* **주소** = 변수에 할당된 메모리 저장 공간의 시작 주소 값 자체

* **포인터** = 그 값을 저장하는 또 다른 메모리 공간



#### [ 주소 ]	주소는 '상수' , 특정 변수의 주소 값은 바뀌지 X

```c
int a, b;	// 일반 변수 선언
int *p;		// 포인터 변수 선언

p = &a;	// p가 a를 가리키도록 설정
p = &b	// p가 변수 b를 가리키도록 바꿈
```



#### [ 포인터 ]	포인터는 '변수', 다른 주소를 대입하여, 그 값을 바꿀 수 있다.

```c
int a;			//일반 변수 선언
int *pa, *pb;	// 가리키는 자료형(여기서 int형)이 같은 두 포인터

pa = pb = &a;	// pa와 pa에 모두 a의 주소 저장
```

이 경우 a 값을 바꾸거나 연산하는데 pa와 pb 모두 사용할 수 있다.

```c
*pa = 10;	// pa가 가리키는 변수 a에 10대입
printf("%d", *pb);	// pb가 가리키는 변수 a 값 10출력
```

단,  ``&a = &b;`` 처럼 a의 주소를 b의 주소로 바꾸는건 불가능 

---

### 2. 주소와 포인터 크기

포인터도 저장공간이므로 크기가 있다.

포인터의 크기 = 저장할 주소의 크기에 따라 결정되는데,

모든 주소와 포인터는 가리키는 자료형과 상관없이 그 크기는 같다.

※ 단, 포인터의 크기는 컴파일러에 따라 다를 수 있다.

주소와 포인터의 크기는 **sizefo 연산자**로 확인할 수 있다.

```c
#include <stdio.h>

int main(void)
{
  char ch;
  int in;
  double db;

  char *pc = &ch;
  int *pi = &in;
  double *pd = &db;

  printf("char형 변수의 주소크기 : %d\n", sizeof(&ch));
  printf("int형 변수의 주소크기 : %d\n", sizeof(&in));
  printf("double형 변수의 주소크기 : %d\n", sizeof(&db));

  printf("char * 포인터가 가리키는 변수의 크기 : %d\n", sizeof(pc));
  printf("int * 포인터가 가리키는 변수의 크기 : %d\n", sizeof(pi));
  printf("double * 포인터가 가리키는 변수의 크기 : %d\n", sizeof(pd));

  return 0;
}

[ 결과 ]
char형 변수의 주소크기 : 4 							
int형 변수의 주소크기 : 4								
double형 변수의 주소크기 : 4					   		  
char * 포인터가 가리키는 변수의 크기 : 4					
int * 포인터가 가리키는 변수의 크기 : 4						 
double * 포인터가 가리키는 변수의 크기 : 4		
```





---

### [ 마지막 정리 ]

1. **주소와 포인터** 는 상수와 변수의 **차이**가 있다.
2. **포인터 크기**는 주소의 크기와 동일하다.
3. **포인터**에 주소를 저장할 때는 가리키는 **자료형**이 같이 있어야한다.
4. **포인터의 주요 기능**중 하나는 함수간에 효과적으로 데이터를 공유하는 것이다.

 

### [ 간접 참조 연산자를 사용한 예 ]

* 대입 연산자 (왼쪽)	``a = 10;``  =  ``*pa = 10;``



* 대입 연산자 (오른쪽)	``b = a;``  =  ``b = *pa;``



* 피연산자	``a + 20;`` = ``*pa + 20;``



* 출력	``printf("%d", a);`` = ``printf("%d", *pa)``



* 입력	``scanf("%d", &a);`` = ``scanf("%d", &*pa);``  or ``scanf("%d", pa);``



---

### [ 주소와 포인터의 특징 ]

* 포인터	``int a, b;``  ,  ``int *p = &a;``  ,  ``p = &b;``



* 포인터의 크기	``int *b``  ,  ``sizeof(p)``



* 포인터의 대입 규칙 	``int *p;``  , ``double *pd;`` , ``pd = p;``





/

/

/



## 다음 Page. C10-1. 배열과 포인터




